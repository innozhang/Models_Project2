/*
 * Project 2: Infusion Pump
 */

//
// Model the power
//

// Mode: Battery or AC?
const BatteryMode = 0
const ACMode = 1
range PMode = BatteryMode .. ACMode // Power has two modes: with AC or Battery

// State: On or Off?
const Off = 0
const On = 1
range PSettings = Off .. On // Does power work?

const EmBattery = 0
const LoBattery = 1
const HiBattery = 2
range Capacity = EmBattery .. HiBattery // The capacity of the battery

POWER = P[BatteryMode][Off][HiBattery],
P[m:PMode][s:PSettings][c:Capacity] =
	// On/Off state of the power by active action 
	(when (s==Off) power_on -> P[m][On][c]
	|when (s==Off) power_off -> P[m][s][c]
	|when (s==On) power_off -> P[m][Off][c]
	|when (s==On) power_on -> P[m][s][c]
	// Switch between BatteryMode and ACMode
	|when (m==BatteryMode) plug_in -> P[ACMode][s][c]
	|when (m==ACMode) unplug -> P[BatteryMode][s][c]
	// In ACMode, charge the battery when necessary
	|when (m==ACMode && c<=LoBattery) charge -> P[m][s][HiBattery]
	// In BatteryMode, consume battery when necessary
	|when (m==BatteryMode && c==HiBattery && s==On) discharge -> P[m][s][LoBattery]
	|when (m==BatteryMode && c==LoBattery && s==On) discharge -> P[m][s][EmBattery]
	|when (m==BatteryMode && c==EmBattery && s==On) empty-> P[m][Off][c]
)@{plug_in,unplug,power_off,power_on}.


//
// Model the User Interface
//

// Whether the pump parameters are set
const ParamsNotSet = 2
const ParamsSet    = 3
range ParamsStateT = ParamsNotSet .. ParamsSet

// Whether the line is locked into the panel
const LineUnlocked = 4
const LineLocked   = 5
range LineLockStateT = LineUnlocked .. LineLocked


// Whether the user interface is confirmed
const NotConfirmed = 0
const Confirmed = 1
range ConfirmStateT = NotConfirmed .. Confirmed

// Whether the pump unit(keypad) is locked
const UnitUnlocked = 6
const UnitLocked   = 7
range UnitLockStateT = UnitUnlocked .. UnitLocked

// The quantity of the medication
const EmptyMed = 0
const UpperMed = 1
range MedCapT = EmptyMed .. UpperMed

USERINTERFACE = (power_on->SETUP[ParamsNotSet][EmptyMed][LineUnlocked][NotConfirmed][UnitUnlocked]), // power_on starts the UI

SETUP[params:ParamsStateT][med:MedCapT][lineLock:LineLockStateT][confirmState:ConfirmStateT][unitLock:UnitLockStateT] =
	// If power_off, goes back
	(power_off->USERINTERFACE
	|when (med == EmptyMed)
		set_rate->enter_value[m:MedCapT]->SETUP[params][m][lineLock][confirmState][unitLock]
	// Set or unset the params
	|when (params == ParamsNotSet && med != EmptyMed)
		press_set -> SETUP[ParamsSet][med][lineLock][confirmState][unitLock]
	|when (params == ParamsNotSet && med != EmptyMed)
		press_cancel -> SETUP[ParamsNotSet][EmptyMed][lineLock][confirmState][unitLock]
	// Clear the already-set params
	|when (params == ParamsSet && lineLock == LineUnlocked)
		clear_rate -> SETUP[ParamsNotSet][EmptyMed][lineLock][confirmState][unitLock]

	// Prepare the line and lock it
	|when (params == ParamsSet && lineLock == LineUnlocked)
		connect_purge_lock -> SETUP[params][med][LineLocked][confirmState][unitLock]

	// Unlock the line
	|when (lineLock == LineLocked && confirmState == NotConfirmed)
		erase_and_unlock_line->SETUP[params][med][LineUnlocked][confirmState][unitLock]
	// Confirm all the settings
	|when (lineLock == LineLocked)
		confirm_settings -> SETUP[params][med][lineLock][Confirmed][unitLock]
	// Change the settings
	|when (confirmState == Confirmed && unitLock == UnitUnlocked)
		change_settings -> SETUP[params][med][lineLock][NotConfirmed][unitLock]
	// Lock the keypad
	|when (confirmState == Confirmed && unitLock == UnitUnlocked)
		lock_unit -> SETUP[params][med][lineLock][confirmState][UnitLocked]
	// Unlock the keypad
	|when (confirmState == Confirmed && unitLock == UnitLocked)
		unlock_unit -> SETUP[params][med][lineLock][confirmState][UnitUnlocked]
	|finish -> USERINTERFACE
).


//
// Model the line
//

const LowerVol = 0
const UpperVol = 1
range VolT = LowerVol .. UpperVol

// After the confirmation, the infusion can begin
// Assumption: the initial medicine amount is the max
LINE = L[EmptyMed],
	L[m:MedCapT] =
	(// take the settings
	enter_value[nm:MedCapT] -> L[nm]
	|power_off -> L[m]
	|confirm_settings -> INFUSION[m][UpperVol]
	),

INFUSION[m:MedCapT][v:VolT] =
	(power_off -> LINE
	|change_settings -> LINE

	|when (m > 0 && v > 0) power_on->dispense -> INFUSION[m - 1][v - 1] // Normal operation
	
	|when (m > 0 && v == 0) fill_in -> INFUSION[m][UpperVol]
	|when (m > 0 && v == 0) empty_line -> INFUSION[m][v]

	|when (m == 0) finish -> LINE
	
	// Three accidents: line_empty, flow_blocked, flow_pinched
	
	|flow_blocked -> BLOCKED[m][v]
	|flow_pinched -> PINCHED[m][v]),

BLOCKED[m:MedCapT][v:VolT] = 
	(power_off -> LINE
	|flow_unblocked -> INFUSION[m][v]),

PINCHED[m:MedCapT][v:VolT] = 
	(power_off -> LINE
	|flow_unpinched -> INFUSION[m][v]).

//
// Model of the Alarm
//

// Whether the alarm is active
const AlarmActivated = 0    // Alarm currently active
const AlarmSilenced  = 1    // Alarm currently inactive
range AlarmStateT = AlarmActivated .. AlarmSilenced

// The causes of the alarm
const Blocked = 0
const Pinched = 1
const Empty = 2
range AlarmTypeT = Blocked .. Empty


ALARM =
	// They will activate the alarm
	(flow_blocked -> INFUSION_ALARM[AlarmActivated][Blocked]
	|flow_pinched -> INFUSION_ALARM[AlarmActivated][Pinched]
	|empty_line -> INFUSION_ALARM[AlarmActivated][Empty]
	|power_off -> ALARM), // Power can be off

INFUSION_ALARM[alarm:AlarmStateT][type:AlarmTypeT] = 
	// AlarmActivated cases
	(when (alarm == AlarmActivated) sound_alarm -> INFUSION_ALARM[alarm][type]
	|when (alarm == AlarmActivated) silence_alarm -> INFUSION_ALARM[AlarmSilenced][type]
	// Alarm events are resolved
	|when (type == Blocked) flow_unblocked -> ALARM
	|when (type == Pinched) flow_unpinched -> ALARM
	|when (type == Empty) fill_in -> ALARM
	// Power can be off
	|power_off -> ALARM).

//
// Model a SEMAPHORE to protect the Alarm, the shared resource
//
const Max = 3
range Int = 0..Max
SEMAPHORE(N=1) = SEMA[N], // the N is num of semaphore, it is 1 in default
SEMA[v:Int]    = ({flow_unblocked,flow_unpinched,fill_in}->SEMA[v+1] // conditions to release
                 |when(v>0) {flow_blocked,flow_pinched,empty_line}->SEMA[v-1] // conditions to acquire
                 ).

//
// Compose all into a whole PUMP system
//
const First = 1
const Second = 2
range LineT = First .. Second


||PUMP = (POWER ||
		  l[LineT]:USERINTERFACE ||
		  l[LineT]:LINE ||
		  l[LineT]:ALARM ||
		  // POWER has impact on all lines, relabeling
		  {l[LineT]}::SEMAPHORE(1))/{power_off/l[First].power_off, power_off/l[Second].power_off,
						            power_on/l[First].power_on, power_on/l[Second].power_on}.

/*-------Property-------*/

// 1. The pump cannot start pumping without the operator first confirming 
// the settings on the pump - SAFETY
fluent PUMP_START[i:LineT] = <{l[i].dispense}, dummy>
fluent SETTINGS_CONFIRMED[i:LineT] = <{l[i].confirm_settings}, dummy>
assert CONFIRMSTART = forall[i:LineT] (!PUMP_START[i] W SETTINGS_CONFIRMED[i])

// 2. Electrical power（AC） can fail at any time - SAFETY & LIVENESS
fluent ELEC_FAIL = <{unplug}, {plug_in}>
assert FAILANYTIME = [](<>ELEC_FAIL)

// 3. If the backup battery power fails, pumping will not occur on any line - LIVENESS
// No battery fail scenario?
fluent BATTERY_FAIL = <{empty}, {charge}>
assert BACKUPFAILNOPUMP = forall[i:LineT] []!(l[i].dispense && BATTERY_FAIL)

// 4. It is always possible to resume pumping after a failure
fluent FAILURE[i:LineT] = <{power_off, l[i].flow_blocked, l[i].flow_pinched, l[i].empty_line}, 
						   {power_on, l[i].flow_unblocked, l[i].flow_unpinched, l[i].fill_in}>
assert RESUME = forall[i:LineT] [](FAILURE[i] -> <>l[i].dispense)

// 5. An alarm will sound on any line failure (blockage, pinching, empty fluid, or whatever failures you model). - SAFETY

// 6. In the absence of errors the pump will continue to pump until the treatment is finished. - SAFETY
fluent ERROR_FREE[i:LineT] = <dummy,{power_off, l[i].flow_blocked, l[i].flow_pinched, l[i].empty_line}>
assert PUMPTILLEMPTY = forall[i:LineT] (l[i].dispense U empty_line)

// 7. The system never deadlocks. - SAFETY

// 8. 
